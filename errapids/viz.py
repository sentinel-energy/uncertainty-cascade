from errapids.io import HDF5Reader
from itertools import cycle, islice, product
from logging import getLogger
from typing import List, Tuple
from holoviews.core.spaces import HoloMap

import numpy as np
import pandas as pd
from pycountry import countries
from tqdm import tqdm

import holoviews as hv
from holoviews import opts

from errapids.err import baselines, qsum, rgroups, scenario_deltas
from errapids.metrics import ScenarioGroups, pan_eu_cf, pan_eu_prod_share

logger = getLogger(__name__)
ix = pd.IndexSlice


def facets(df: pd.DataFrame, region: str, stack: str) -> Tuple:
    """Create a bar chart, and a faceted set of uncertainties

    The number of countries are limited to the ``region`` defined in `rgroups`.
    The index level (or dimension) ``stack`` is "stacked" in the summary plot,
    and summed over in the undertainty plots.  The unceratainty plots are
    faceted over the "remaining" index level (or dimension) - "region" or
    "technology".

    Parameters
    ----------
    df : pandas.DataFrame
        Dataframe

    region : str
        Region group, as defined in `rgroups`

    stack : str
        Index level (or dimension) to stack/sum over

    Returns
    -------
    Tuple[holoviews.Bars, holoviews.HoloMap, holoviews.HoloMap]
        The plot elements, the holomaps contain faceted uncertainty spreads,
        and the corresponding tables

    """
    name = df.columns[0]

    # for total_* metrics
    if not isinstance(df.index, pd.MultiIndex):
        assert df.index.name == "scenario"
        rmax = 1.2 * df[[name, "errhi"]].sum(axis=1).max()
        bars = hv.Bars(df, vdims=[name], kdims=["scenario"]).opts(
            tools=["hover"], ylim=(0, rmax)
        )
        errs = hv.Spread(df, vdims=[name, "errlo", "errhi"], kdims=["scenario"]).opts(
            fill_alpha=0.7
        ) * hv.HLine(df.iloc[0, 0])
        return bars, errs, hv.Table(df.reset_index())

    if stack and stack not in df.index.names:
        raise ValueError(f"{name}: {stack=} not present")

    # systemwide_* metrics do not have regions
    if region and "region" in df.index.names:
        grp = rgroups[region]  # noqa, choose region, implicitly used in df.query(..)
        df = df.query("region in @grp")
    elif region:
        logger.warning(f"{name}: no region level in index, {region=} ignored")
    else:
        logger.info(f"{name}: no region level in index")

    grpd = df.groupby(df.index.names.difference([stack])).agg(
        {name: np.sum, "errlo": qsum, "errhi": qsum}
    )
    if isinstance(grpd.index, pd.MultiIndex):
        grpd = grpd.reindex(index=list(baselines), level="scenario")
    else:
        grpd = grpd.reindex(index=list(baselines))

    space = 1.7 if stack == "technology" else 1.2
    rmax = space * grpd[[name, "errhi"]].sum(axis=1).max()

    # maintain original order
    kdims = df.index.names.difference(["scenario"])
    if stack:
        stackidx = kdims.index(stack)
        kdims = list(islice(cycle(kdims), stackidx + 1, stackidx + 1 + len(kdims)))
    bars = hv.Bars(df.query("scenario == 'all'"), vdims=[name], kdims=kdims).opts(
        stacked=bool(stack), tools=["hover"], ylim=(0, rmax)
    )

    faceted_lvl = grpd.index.names[0]
    if isinstance(grpd.index, pd.MultiIndex):
        lvl_vals = grpd.index.levels[grpd.index.names.index(faceted_lvl)]
    else:
        lvl_vals = grpd.index
    errs = HoloMap(
        {
            val: (
                hv.Spread(
                    grpd.loc[val, :], vdims=list(grpd.columns), kdims=["scenario"]
                ).opts(fill_alpha=0.7, ylim=(0, rmax))
                * hv.HLine(grpd.loc[val, name].iloc[0])
            )
            for val in lvl_vals
        },
        kdims=[faceted_lvl],
    )
    tbl = HoloMap(
        {
            val: hv.Table(df.query(f"{faceted_lvl} == @val").reset_index())
            for val in lvl_vals
        },
        kdims=[faceted_lvl],
    )
    return bars, errs, tbl


def layout(bars, errs, tbl, height):
    # FIXME: arrange in rows: 2:1, 3
    layout = (
        hv.Layout(tbl + errs + bars)
        .opts(toolbar="right", height=height)
        .opts(
            opts.Table(width=2 * height),
            opts.Spread(width=height),
            opts.Bars(width=2 * height),
        )
        .cols(2)
    )
    return layout


def draw_panel(df):
    if df.index.names[0] == "region":
        _title = lambda k: countries.lookup(k).name
    else:
        _title = lambda k: k
    # df.index.names == [key, "scenario"]
    plots = [
        (
            hv.Spread(df.loc[ix[key, :], :], vdims=list(df.columns), kdims=["scenario"])
            * hv.HLine(df.loc[ix[key, "all"], :].iloc[0])
        ).opts(width=400, height=300, tools=["hover"], title=_title(key))
        for key in df.index.levels[0]
    ]
    plots.append(hv.Table(df.reset_index()))
    return plots


class plotmanager:
    """Manage and render the plots

    Reads and processes the data on instantiation.  The plots are generated by
    calling :meth:`plot`.  All plots can be written to a directory with
    :meth:`write`.

    """

    @classmethod
    def from_netcdf(cls, datadir: str, glob: str, **kwargs):
        return cls(ScenarioGroups.from_dir(datadir, glob, pretty=False), **kwargs)

    @classmethod
    def from_hdf5(cls, h5path: str, **kwargs):
        return cls(HDF5Reader(h5path), **kwargs)

    def __init__(self, data, istransmission: bool = False):
        self._data = data
        self._arrays = {
            name: scenario_deltas(self._data[name], istransmission)
            for name in self._data.metrics
            if name not in self._data.derived
        }

    @property
    def metrics(self):
        return list(self._arrays) + self._data.derived

    @property
    def regions(self) -> List[str]:
        return list(rgroups)

    def agg_capacity_factor(self, groupby: str):
        df = pan_eu_cf(self._data["carrier_prod"], self._data["energy_cap"], groupby)
        return hv.Layout(draw_panel(df)).opts(toolbar="right").cols(3)

    def agg_carrier_prod_share(self):
        df = pan_eu_prod_share(self._data["carrier_prod"])
        return hv.Layout(draw_panel(df)).opts(toolbar="right").cols(3)

    def agg_plot(
        self, metric: str, region: str, stack: str, height: int = 400
    ) -> hv.Layout:
        """Render an aggregated plot

        Parameters
        ----------
        metric : str
            Metric to plot

        region : str
            Region subset to include in plot

        stack : str
            Index level to stack

        height : int (default: 400)
            Height of individual plots, everything else is scaled accordingly

        Returns
        -------
        hvplot.Layout
            A 2-column ``hvplot.Layout`` with the different facets of the plot

        """
        if metric in self._data.derived:
            raise ValueError(f"{metric}: derived metric, cannot draw aggregated plot")
        bars, errs, tbl = facets(self._arrays[metric], region, stack)
        return layout(bars, errs, tbl, height)

    def write(self, plotdir: str):
        """Write all plots to a directory

        Parameters
        ----------
        plotdir : str
            Plot directory

        """
        pbar1 = tqdm(self.metrics)
        for metric in pbar1:
            pbar1.set_description(f"{metric}")
            if "total" in metric or "systemwide" in metric:
                hv.save(self.agg_plot(metric, "", ""), f"{plotdir}/{metric}.html")
            elif metric in self._data.derived:
                if metric == "capacity_factor":
                    for groupby in ("region", "technology"):
                        plot = self.agg_capacity_factor(groupby)
                        hv.save(plot, f"{plotdir}/{metric}_{groupby}.html")
                elif metric == "carrier_prod_share":
                    plot = self.agg_carrier_prod_share()
                    hv.save(plot, f"{plotdir}/{metric}.html")
                else:
                    RuntimeError("don't know how it got here")
            else:
                pbar2 = tqdm(rgroups)
                for region, stack in product(pbar2, ("region", "technology")):
                    pbar2.set_description(f"{region=}")
                    plots = self.agg_plot(metric, region, stack)
                    hv.save(plots, f"{plotdir}/{metric}_{region}_{stack}.html")
